(window.webpackJsonp=window.webpackJsonp||[]).push([[90],{552:function(a,t,r){"use strict";r.r(t);var e=r(14),v=Object(e.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"yarn"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#yarn"}},[a._v("#")]),a._v(" Yarn")]),a._v(" "),r("p"),r("div",{staticClass:"table-of-contents"},[r("ul",[r("li",[r("a",{attrs:{href:"#yarn的新特性"}},[a._v("YARN的新特性")])]),r("li",[r("a",{attrs:{href:"#hadoop的调度策略的实现-你们使用的是那种策略-为什么"}},[a._v("hadoop的调度策略的实现,你们使用的是那种策略,为什么?")]),r("ul",[r("li",[r("a",{attrs:{href:"#fifo"}},[a._v("FIFO")])])])]),r("li",[r("a",{attrs:{href:"#capacityscheduler"}},[a._v("CapacityScheduler")])]),r("li",[r("a",{attrs:{href:"#fairscheduler"}},[a._v("FairScheduler")])]),r("li",[r("a",{attrs:{href:"#画一个yarn架构图-及其通信流程"}},[a._v("画一个yarn架构图,及其通信流程；")])]),r("li",[r("a",{attrs:{href:"#hadoop的作业提交流程"}},[a._v("Hadoop的作业提交流程")])]),r("li",[r("a",{attrs:{href:"#如何减少hadoop-map端到reduce端的数据传输量"}},[a._v("如何减少Hadoop Map端到Reduce端的数据传输量")])])])]),r("p"),a._v(" "),r("h2",{attrs:{id:"yarn的新特性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#yarn的新特性"}},[a._v("#")]),a._v(" YARN的新特性")]),a._v(" "),r("h2",{attrs:{id:"hadoop的调度策略的实现-你们使用的是那种策略-为什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#hadoop的调度策略的实现-你们使用的是那种策略-为什么"}},[a._v("#")]),a._v(" hadoop的调度策略的实现,你们使用的是那种策略,为什么?")]),a._v(" "),r("p",[r("a",{attrs:{href:"http://jxy.me/2015/04/30/yarn-resource-scheduler/",target:"_blank",rel:"noopener noreferrer"}},[a._v("YARN资源调度策略 // foolbear的冥想盆"),r("OutboundLink")],1)]),a._v(" "),r("p",[a._v("对一个资源管理系统而言，首先要定义出资源的种类，然后将每种资源量化，才能管理。这就是资源抽象的过程。")]),a._v(" "),r("p",[a._v("Container")]),a._v(" "),r("p",[a._v("Container是RM分配资源的基本单位。每个Container包含特定数量的CPU资源和内存资源，用户的程序运行在Container中，有点类似虚拟机。RM负责接收用户的资源请求并分配Container，NM负责启动Container并监控资源使用。如果使用的资源（目前只有内存）超出Container的限制，相应进程会被NM杀掉。")]),a._v(" "),r("p",[a._v("在YARN中，调度器是一个可插拔的组件，常见的有FIFO，CapacityScheduler，FairScheduler。可以通过配置文件选择不同的调度器。")]),a._v(" "),r("h3",{attrs:{id:"fifo"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#fifo"}},[a._v("#")]),a._v(" FIFO")]),a._v(" "),r("p",[a._v("最简单、也是默认的调度器。只有一个队列，所有用户共享。\n资源分配的过程也非常简单，先到先得，所以很容易出现一个用户占满集群所有资源的情况。\n可以设置ACL，但不能设置各个用户的优先级。")]),a._v(" "),r("p",[a._v("优点是简单好理解，缺点是无法控制每个用户的资源使用。\n一般不能用于生产环境中。")]),a._v(" "),r("h2",{attrs:{id:"capacityscheduler"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#capacityscheduler"}},[a._v("#")]),a._v(" CapacityScheduler")]),a._v(" "),r("p",[a._v("在FIFO基础上，增加了"),r("strong",[a._v("多用户支持")]),a._v("，最大化集群吞吐量和利用率。")]),a._v(" "),r("p",[a._v("原理： 每个用户只能使用特定量资源，但是集群空闲的时候，也可以使用整个汲取你的资源。")]),a._v(" "),r("p",[a._v("特点：")]),a._v(" "),r("ol",[r("li",[a._v("单用户下，和FIFO时一样的")]),a._v(" "),r("li",[a._v("xml配置")]),a._v(" "),r("li",[a._v("树状，继承")]),a._v(" "),r("li",[a._v("ACL")]),a._v(" "),r("li",[a._v("动态变化，最多100%")])]),a._v(" "),r("p",[a._v("优点：")]),a._v(" "),r("ol",[r("li",[a._v("灵活，集群利用率高")]),a._v(" "),r("li",[a._v("灵活：某个用户占用100%的时候，如果不释放，其他必须等待，不支持抢占调度")])]),a._v(" "),r("h2",{attrs:{id:"fairscheduler"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#fairscheduler"}},[a._v("#")]),a._v(" FairScheduler")]),a._v(" "),r("p",[r("strong",[a._v("推荐使用")])]),a._v(" "),r("p",[a._v("优先"),r("strong",[a._v("保持公平")]),a._v(" 每个用户只有特定数量的资源可以用，不可能超出这个限制，即使集群整体很空闲")]),a._v(" "),r("p",[a._v("特点：")]),a._v(" "),r("ol",[r("li",[a._v("支持抢占调度")])]),a._v(" "),r("p",[a._v("优点：")]),a._v(" "),r("ol",[r("li",[a._v("稳定")]),a._v(" "),r("li",[a._v("管理方便")]),a._v(" "),r("li",[a._v("运维成本低")])]),a._v(" "),r("p",[a._v("缺点：")]),a._v(" "),r("ol",[r("li",[a._v("相对于CapacityScheduler，牺牲了灵活性")]),a._v(" "),r("li",[a._v("经常一个队列用满，但是集群很空闲")])]),a._v(" "),r("p",[a._v("需要熟悉下Yarn资源调度机制")]),a._v(" "),r("h2",{attrs:{id:"画一个yarn架构图-及其通信流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#画一个yarn架构图-及其通信流程"}},[a._v("#")]),a._v(" 画一个yarn架构图,及其通信流程；")]),a._v(" "),r("p",[r("img",{attrs:{src:"https://static.lovedata.net/jpg/2018/7/4/33789bff3b6481fa26da13c743d815c7.jpg",alt:"image"}}),a._v(" "),r("img",{attrs:{src:"https://static.lovedata.net/jpg/2018/7/4/50b9c520a08ac25c70008cf1fb620ed9.jpg",alt:"image"}})]),a._v(" "),r("p",[r("img",{attrs:{src:"https://static.lovedata.net/jpg/2018/7/4/5ad787782060aa4e9310f186b2cedbf8.jpg",alt:"image"}})]),a._v(" "),r("h2",{attrs:{id:"hadoop的作业提交流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#hadoop的作业提交流程"}},[a._v("#")]),a._v(" Hadoop的作业提交流程")]),a._v(" "),r("p",[r("img",{attrs:{src:"https://static.lovedata.net/jpg/2018/7/4/5ad787782060aa4e9310f186b2cedbf8.jpg",alt:"image"}})]),a._v(" "),r("h2",{attrs:{id:"如何减少hadoop-map端到reduce端的数据传输量"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如何减少hadoop-map端到reduce端的数据传输量"}},[a._v("#")]),a._v(" 如何减少Hadoop Map端到Reduce端的数据传输量")]),a._v(" "),r("p",[a._v("减少传输量，可以让map处理完，让同台的reduce直接处理，理想情况下，没有数据传输。")])])}),[],!1,null,null,null);t.default=v.exports}}]);