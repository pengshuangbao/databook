(window.webpackJsonp=window.webpackJsonp||[]).push([[108],{568:function(e,t,a){"use strict";a.r(t);var r=a(14),s=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"学习资源"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#学习资源"}},[e._v("#")]),e._v(" 学习资源")]),e._v(" "),a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#学习网站"}},[e._v("学习网站")])]),a("li",[a("a",{attrs:{href:"#推荐博客"}},[e._v("推荐博客")]),a("ul",[a("li",[a("a",{attrs:{href:"#z小赵系列"}},[e._v("z小赵系列")])]),a("li",[a("a",{attrs:{href:"#kafka数据可靠性深度解读"}},[e._v("Kafka数据可靠性深度解读")]),a("ul",[a("li",[a("a",{attrs:{href:"#分区结构"}},[e._v("分区结构")])])])]),a("li",[a("a",{attrs:{href:"#复制原理和同步方式"}},[e._v("复制原理和同步方式")])]),a("li",[a("a",{attrs:{href:"#isr"}},[e._v("ISR")]),a("ul",[a("li",[a("a",{attrs:{href:"#可靠性保障"}},[e._v("可靠性保障")])]),a("li",[a("a",{attrs:{href:"#request-required-acks-1的两种情况"}},[e._v("request.required.acks=-1的两种情况")])])])])])])])]),a("p"),e._v(" "),a("h2",{attrs:{id:"学习网站"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#学习网站"}},[e._v("#")]),e._v(" 学习网站")]),e._v(" "),a("h2",{attrs:{id:"推荐博客"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#推荐博客"}},[e._v("#")]),e._v(" 推荐博客")]),e._v(" "),a("h3",{attrs:{id:"z小赵系列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#z小赵系列"}},[e._v("#")]),e._v(" z小赵系列")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://mp.weixin.qq.com/s/3bv9a1xYHn-9xgDOH1UyHg",target:"_blank",rel:"noopener noreferrer"}},[e._v("重要：Kafka第3篇之一条消息如何被存储到Broker上"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"https://mp.weixin.qq.com/s/j9TiFmO63ekePxNk10mnww",target:"_blank",rel:"noopener noreferrer"}},[e._v("Kafka系列第4篇：消息发送时，网络“偷偷”帮忙做的那点事儿"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"https://mp.weixin.qq.com/s/OYnyq_5jFSzVQQTs30YLmg",target:"_blank",rel:"noopener noreferrer"}},[e._v('kafka系列第5篇：一文读懂消费者背后的那点"猫腻"'),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"https://mp.weixin.qq.com/s/OU6LwmSaRmzz2Xm0-Bb0sA",target:"_blank",rel:"noopener noreferrer"}},[e._v("Kafka系列第6篇：消息是如何在服务端存储与读取的，你真的知道吗？"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"https://mp.weixin.qq.com/s/WRYOf0NH99hWtH2tGx6TcA",target:"_blank",rel:"noopener noreferrer"}},[e._v("Kafka：你必须要知道集群内部工作原理的一些事！"),a("OutboundLink")],1)]),e._v(" "),a("h3",{attrs:{id:"kafka数据可靠性深度解读"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#kafka数据可靠性深度解读"}},[e._v("#")]),e._v(" Kafka数据可靠性深度解读")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://www.infoq.cn/article/depth-interpretation-of-kafka-data-reliability",target:"_blank",rel:"noopener noreferrer"}},[e._v("Kafka数据可靠性深度解读-InfoQ"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("img",{attrs:{src:"https://static.lovedata.net/21-04-08-14d9c18012f76523cc5f63c31fe48074.png",alt:"image"}})]),e._v(" "),a("h4",{attrs:{id:"分区结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分区结构"}},[e._v("#")]),e._v(" 分区结构")]),e._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[e._v("drwxr-xr-x "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("2")]),e._v(" root root "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("4096")]),e._v(" Apr "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("10")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("16")]),e._v(":10 topic_vms_test-0\ndrwxr-xr-x "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("2")]),e._v(" root root "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("4096")]),e._v(" Apr "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("10")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("16")]),e._v(":10 topic_vms_test-1\ndrwxr-xr-x "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("2")]),e._v(" root root "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("4096")]),e._v(" Apr "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("10")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("16")]),e._v(":10 topic_vms_test-2\ndrwxr-xr-x "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("2")]),e._v(" root root "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("4096")]),e._v(" Apr "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("10")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("16")]),e._v(":10 topic_vms_test-3\n")])])]),a("p",[e._v("segment结构")]),e._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[e._v("00000000000000000000.index\n00000000000000000000.log\n00000000000000170410.index\n00000000000000170410.log\n00000000000000239430.index\n00000000000000239430.log\n")])])]),a("p",[e._v("index与log的对应关系")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://static.lovedata.net/21-04-08-c7dad78669048359df370a75f36a5e2c.png",alt:"image"}})]),e._v(" "),a("blockquote",[a("p",[e._v("“.index”索引文件存储大量的元数据，“.log”数据文件存储大量的消息，索引文件中的元数据指向对应数据文件中 message 的"),a("strong",[e._v("物理偏移地址")])]),e._v(" "),a("p",[e._v("其中以“.index”索引文件中的元数据 [3, 348] 为例，在“.log”数据文件表示第 3 个消息，即在全局 partition 中表示 170410+3=170413 个消息，该消息的物理偏移地址为 348。")]),e._v(" "),a("p",[e._v("那么如何从 partition 中通过 offset 查找 message 呢？")]),e._v(" "),a("p",[e._v("以上图为例，读取 offset="),a("strong",[e._v("170418")]),e._v(" 的消息，首先查找 segment 文件，其中 00000000000000000000.index 为最开始的文件，第二个文件为 00000000000000170410.index（起始偏移为 170410+1=170411），而第三个文件为 00000000000000239430.index（起始偏移为 239430+1=239431），所以这个 offset=170418 就落到了"),a("strong",[e._v("第二个文件")]),e._v("之中。其他后续文件可以依次类推，以其实偏移量命名并排列这些文件，然后根据二分查找法就可以快速定位到具体文件位置。其次根据 00000000000000170410.index 文件中的 [8,1325] 定位到 00000000000000170410.log 文件中的 1325 的位置进行读取。")]),e._v(" "),a("blockquote",[a("p",[e._v("要是读取 offset=170418 的消息，从 00000000000000170410.log 文件中的 1325 的位置进行读取，那么怎么知道何时读完本条消息，否则就读到下一条消息的内容了？这个就需要联系到消息的物理结构了，消息都具有固定的物理结构，包括："),a("strong",[e._v("offset（8 Bytes）、消息体的大小（4 Bytes）、crc32（4 Bytes）、magic（1 Byte）、attributes（1 Byte）、key length（4 Bytes）、key（K Bytes）、payload(N Bytes)")]),e._v(" 等等字段，可以确定一条消息的大小，即读取到哪里截止。")])])]),e._v(" "),a("h3",{attrs:{id:"复制原理和同步方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#复制原理和同步方式"}},[e._v("#")]),e._v(" 复制原理和同步方式")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://static.lovedata.net/21-04-08-fbedd6c71a0cff1fc25994b4fd6fb712.png",alt:"image"}})]),e._v(" "),a("p",[e._v("LEO，LogEndOffset 的缩写，表示每个partition 的log 最后一条Message 的位置")]),e._v(" "),a("p",[e._v("HW 是HighWatermark 的缩写，是指consumer 能够看到的此partition 的位置")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://static.lovedata.net/21-04-08-09881eb6cbe36944091358fddf161b25.png",alt:"image"}})]),e._v(" "),a("h3",{attrs:{id:"isr"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#isr"}},[e._v("#")]),e._v(" ISR")]),e._v(" "),a("p",[e._v("ISR (In-Sync Replicas)，这个是指副本同步队列,对吞吐量有一定影响，但是极大增强了可用性")]),e._v(" "),a("p",[e._v("ISR 列表，follower 从 leader 同步数据有一些延迟（包括延迟时间 replica.lag.time.max.ms 和延迟条数 replica.lag.max.messages 两个维度, 当前最新的版本 0.10.x 中只支持 "),a("strong",[e._v("replica.lag.time.max.ms")]),e._v(" 这个维度")]),e._v(" "),a("p",[e._v("AR 默认情况下 Kafka 的 replica 数量为 1，即每个 partition 都有一个唯一的 leader，为了确保消息的可靠性，通常应用中将其值 (由 broker 的参数 offsets.topic.replication.factor 指定) 大小设置为大于 1，比如 3。 所有的副本（replicas）统称为 Assigned Replicas，即 "),a("strong",[e._v("AR")]),e._v("。")]),e._v(" "),a("p",[e._v("ISR 是 AR 中的一个子集,由leader维护ISR")]),e._v(" "),a("p",[e._v("Kafka 0.10.x 版本后移除了 replica.lag.max.messages 参数，只保留了 replica.lag.time.max.ms 作为 ISR 中副本管理的参数。为什么这样做呢？")]),e._v(" "),a("blockquote",[a("p",[e._v("主要是峰值流量的影响，比如某一刻 producer瞬间发送很大的消息道broker，而这个时候follower都会被认为是lag的，剔除isr，后面有重新拉去，又回到了isr，所以造成了性能的浪费。")])]),e._v(" "),a("p",[a("strong",[e._v("HW")]),e._v(" 俗称高水位，HighWatermark 的缩写，取一个 partition 对应的 ISR 中最小的 LEO 作为 HW，consumer只能消费到hw的位置，leader，和follower各自维护自己的hw，对于leader，producer发送消息后，不能立即更新hw，要等所有副本都同步后更新 hw")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://static.lovedata.net/21-04-08-830fe2794365c6b564a42153581748e4.png",alt:"image"}})]),e._v(" "),a("h4",{attrs:{id:"可靠性保障"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#可靠性保障"}},[e._v("#")]),e._v(" 可靠性保障")]),e._v(" "),a("p",[e._v("request.required.acks 参数来设置数据可靠性的级别：")]),e._v(" "),a("ol",[a("li",[e._v("1 (默认) 只要leader收到了，就可以了，如果leader 挂掉了，就丢了\n"),a("ol",[a("li",[a("img",{attrs:{src:"https://static.lovedata.net/21-04-08-0a9e3f491d6c1451483201ee2c3c7990.png",alt:"image"}})])])]),e._v(" "),a("li",[e._v("0 什么保证都没有，只管发送，吞吐量最高，但是可靠性最差")]),e._v(" "),a("li",[e._v("-1(all) producer 需要等待 ISR 中的所有 follower 都确认接收到数据后才算一次发送完成，可靠性最高， 也不能保证数据完全不丢失，例如如果 ISR中只有leader，这就变成 acks=1的情况")])]),e._v(" "),a("p",[e._v("那么如何保证可靠性？")]),e._v(" "),a("p",[e._v("在设置 request.required.acks=-1 的同时，也要 "),a("strong",[e._v("min.insync.replicas")]),e._v(" 这个参数 (可以在 broker 或者 topic 层面进行设置) 的配合，这样才能发挥最大的功效")]),e._v(" "),a("p",[e._v("min.insync.replicas 这个参数设定 ISR 中的最小副本数是多少，默认为1，"),a("strong",[e._v("仅当 request.required.acks 参数设置为 -1 时，此参数才生效")])]),e._v(" "),a("blockquote",[a("p",[e._v("如果 ISR 中的副本数少于 min.insync.replicas 配置的数量时，客户端会返回异常：org.apache.kafka.common.errors.NotEnoughReplicasExceptoin: Messages are rejected since there are fewer in-sync replicas than required。")])]),e._v(" "),a("h4",{attrs:{id:"request-required-acks-1的两种情况"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#request-required-acks-1的两种情况"}},[e._v("#")]),e._v(" request.required.acks=-1的两种情况")]),e._v(" "),a("p",[e._v("同步（Kafka 默认为同步，即 producer.type=sync）的发送模式，replication.factor>=2 且 min.insync.replicas>=2 的情况下，不会丢失数据。")]),e._v(" "),a("p",[e._v("情况1: acks=-1 的情况下，数据发送到 leader, ISR 的 follower 全部完成数据同步后，leader 此时挂掉，那么会选举出新的 leader，数据不会丢失。")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://static.lovedata.net/21-04-08-7c33953e8132b872d307fc6de56d325f.png",alt:"image"}})]),e._v(" "),a("p",[e._v("情况2: acks=-1 的情况下，数据发送到 leader 后 ，部分 ISR 的副本同步，leader 此时挂掉。f1 和 f2 都有可能变成leader，p发送异常，可能会重发数据，那么就重复了")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://static.lovedata.net/21-04-08-6bdc9ae18890a0bf5bbc913d0f126a42.png",alt:"image"}})])])}),[],!1,null,null,null);t.default=s.exports}}]);