(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{479:function(e,t,r){"use strict";r.r(t);var a=r(14),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"lsm-tree"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#lsm-tree"}},[e._v("#")]),e._v(" LSM-Tree")]),e._v(" "),r("p"),r("div",{staticClass:"table-of-contents"},[r("ul",[r("li",[r("a",{attrs:{href:"#【paper笔记】the-log-structured-merge-tree-lsm-tree"}},[e._v("【Paper笔记】The Log structured Merge-Tree（LSM-Tree）")])]),r("li",[r("a",{attrs:{href:"#彻底搞懂lsm-tree"}},[e._v("彻底搞懂LSM-Tree")]),r("ul",[r("li",[r("a",{attrs:{href:"#是什么"}},[e._v("是什么？")])]),r("li",[r("a",{attrs:{href:"#有什么特点"}},[e._v("有什么特点？")])]),r("li",[r("a",{attrs:{href:"#磁盘结构"}},[e._v("磁盘结构")])]),r("li",[r("a",{attrs:{href:"#结构组成"}},[e._v("结构组成")])]),r("li",[r("a",{attrs:{href:"#写lsm-tree"}},[e._v("写lsm-tree")])]),r("li",[r("a",{attrs:{href:"#合并"}},[e._v("合并")])]),r("li",[r("a",{attrs:{href:"#读写例子"}},[e._v("读写例子")])]),r("li",[r("a",{attrs:{href:"#合并过程"}},[e._v("合并过程")])])])])])]),r("p"),e._v(" "),r("h2",{attrs:{id:"【paper笔记】the-log-structured-merge-tree-lsm-tree"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#【paper笔记】the-log-structured-merge-tree-lsm-tree"}},[e._v("#")]),e._v(" 【Paper笔记】The Log structured Merge-Tree（LSM-Tree）")]),e._v(" "),r("blockquote",[r("p",[r("a",{attrs:{href:"https://kernelmaker.github.io/lsm-tree",target:"_blank",rel:"noopener noreferrer"}},[e._v("【Paper笔记】The Log structured Merge-Tree（LSM-Tree）  "),r("OutboundLink")],1)])]),e._v(" "),r("h2",{attrs:{id:"彻底搞懂lsm-tree"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#彻底搞懂lsm-tree"}},[e._v("#")]),e._v(" 彻底搞懂LSM-Tree")]),e._v(" "),r("blockquote",[r("p",[r("a",{attrs:{href:"https://mp.weixin.qq.com/s/2Njngm52jNOo0nu50TvRyQ",target:"_blank",rel:"noopener noreferrer"}},[e._v("彻底搞懂LSM-Tree"),r("OutboundLink")],1)])]),e._v(" "),r("h3",{attrs:{id:"是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#是什么"}},[e._v("#")]),e._v(" 是什么？")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("LSM-Tree，即Log-Structured Merge-Tree（"),r("strong",[e._v("日志结构合并树")]),e._v("）。")])]),e._v(" "),r("li",[r("p",[e._v("LevelDB和RocksDB等使用的存储引擎，拥有着优异的写性能和不错的读性能。")])])]),e._v(" "),r("h3",{attrs:{id:"有什么特点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#有什么特点"}},[e._v("#")]),e._v(" 有什么特点？")]),e._v(" "),r("ul",[r("li",[e._v("优异的写性能")]),e._v(" "),r("li",[e._v("不错的读性能")]),e._v(" "),r("li",[e._v("顺序写磁盘，大幅度提升写的性能，牺牲一部分读的性能提高写性能")])]),e._v(" "),r("h3",{attrs:{id:"磁盘结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#磁盘结构"}},[e._v("#")]),e._v(" 磁盘结构")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://static.lovedata.net/21-06-07-4dc24c6f2bda17693df82ada49375934.png",alt:"image"}})]),e._v(" "),r("h3",{attrs:{id:"结构组成"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#结构组成"}},[e._v("#")]),e._v(" 结构组成")]),e._v(" "),r("p",[e._v("LSM-Tree是由两个或以上的存储结构组成的，由一个驻存在内存中的树结构和多个位于磁盘的树结构组成。我们一般把在内存中的树结构称为C0-Tree（小树），具体结构可以是任何方便键值查找的数据结构，例如"),r("strong",[e._v("红黑树，跳表等")]),e._v("；在磁盘中的树一开始为C1-Tree（大树），以后由于合并递增会有C2-Tree，C3-Tree……Ck-Tree，树从小到大依次递增。")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://static.lovedata.net/21-06-07-6149b08557d2a7eb0004748f036db23b.png",alt:"image"}})]),e._v(" "),r("h3",{attrs:{id:"写lsm-tree"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#写lsm-tree"}},[e._v("#")]),e._v(" 写lsm-tree")]),e._v(" "),r("p",[e._v("每次写操作，要先写WAL，然后再去更新内存")]),e._v(" "),r("h3",{attrs:{id:"合并"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#合并"}},[e._v("#")]),e._v(" 合并")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://static.lovedata.net/21-06-07-4af8ac6f120a72a5b1f2ca6fe7686f49.png",alt:"image"}})]),e._v(" "),r("p",[e._v("一开始数据会存放在C0-Tree中即内存中，当达到C0-Tree的阈值时会触发合并，将C0-Tree的数据合并写入到C1-Tree，过程类似于归并排序。C0-Tree和C1-Tree（old）会合并成为一个C1-Tree（new），C1-Tree（old）会被删除，用C1-Tree（new）代替。当C1-Tree达到一定大小，也会和下一层进行合并。")]),e._v(" "),r("p",[r("strong",[e._v("数据插入，删除，更新")]),e._v("都是"),r("strong",[e._v("通过****追加")]),e._v("的方式进行（后面会通过图的方式形象的展示给大家），尽最大可能保证顺序写，避免随机写。。")]),e._v(" "),r("h3",{attrs:{id:"读写例子"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#读写例子"}},[e._v("#")]),e._v(" 读写例子")]),e._v(" "),r("p",[e._v("例如往树中写入了"),r("code",[e._v("a = 5")]),e._v("，然后该数据经过多次的合并已经存储到Ck-Tree了，但是现在写入一个"),r("code",[e._v("a = 100")]),e._v("，那么会先写入log，然后在C0-Tree进行更新。那么我们要进行查询的时候，首先会到内存中进行查询a，内存中有直接进行返回，内存中没有会先查找C1-Tree，如果还是没有则查找C2-Tree……Ck-Tree。所以Ck-Tree存在有老数据是不影响正确结果的返回，查找循序是从小阶级Tree开始，所以会先返回"),r("code",[e._v("a = 100")]),e._v("，虽然不会读取到老数据，但是会造成老数据（无用的数据）暂时停留在磁盘中，当数据a也被合并到Ck-Tree时，会把老数据清理合并，解决这个问题。")]),e._v(" "),r("h3",{attrs:{id:"合并过程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#合并过程"}},[e._v("#")]),e._v(" 合并过程")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://static.lovedata.net/21-06-07-90ce05c8ab77cfc7e27763d8d2a46055.png",alt:"image"}})])])}),[],!1,null,null,null);t.default=s.exports}}]);