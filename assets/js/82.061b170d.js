(window.webpackJsonp=window.webpackJsonp||[]).push([[82],{544:function(t,e,a){"use strict";a.r(e);var s=a(14),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"状态原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#状态原理"}},[t._v("#")]),t._v(" 状态原理")]),t._v(" "),a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#参考"}},[t._v("参考")])]),a("li",[a("a",{attrs:{href:"#flink-state-最佳实践"}},[t._v("Flink State 最佳实践")]),a("ul",[a("li",[a("a",{attrs:{href:"#operator-state-使用建议"}},[t._v("Operator state 使用建议")])]),a("li",[a("a",{attrs:{href:"#keyed-state-使用建议"}},[t._v("**Keyed state 使用建议**")])]),a("li",[a("a",{attrs:{href:"#一些使用-checkpoint-的使用建议"}},[t._v("**一些使用 checkpoint 的使用建议**")])])])])])]),a("p"),t._v(" "),a("h2",{attrs:{id:"参考"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),a("ol",[a("li",[a("a",{attrs:{href:"https://ververica.cn/developers/flink-state-best-practices/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Flink State 最佳实践"),a("OutboundLink")],1)])]),t._v(" "),a("h2",{attrs:{id:"flink-state-最佳实践"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flink-state-最佳实践"}},[t._v("#")]),t._v(" Flink State 最佳实践")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("四个维度来区分两种不同的 state：operator state 以及 keyed state。")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("是否存在当前处理的 key")]),t._v("（current key）：operator state 是没有当前 key 的概念，而 keyed state 的数值总是与一个 current key 对应。")]),t._v(" "),a("li",[a("strong",[t._v("存储对象是否 on heap:")]),t._v(" 目前 operator state backend 仅有一种 on-heap 的实现；而 keyed state backend 有 on-heap 和 off-heap（RocksDB）的多种实现。")]),t._v(" "),a("li",[a("strong",[t._v("是否需要手动声明快照")]),t._v("（snapshot）"),a("strong",[t._v("和恢复")]),t._v(" (restore) "),a("strong",[t._v("方法")]),t._v("：operator state 需要手动实现 snapshot 和 restore 方法；而 keyed state 则由 backend 自行实现，对用户透明。")]),t._v(" "),a("li",[a("strong",[t._v("数据大小")]),t._v("：一般而言，我们认为 operator state 的数据规模是比较小的；认为 keyed state 规模是相对比较大的。需要注意的是，这是一个经验判断，不是一个绝对的判断区分标准。")])])]),t._v(" "),a("li",[a("p",[a("img",{attrs:{src:"https://static.lovedata.net/20-08-12-3cf2b0941431e750bed467d0be92cdf5.png",alt:"image"}})])]),t._v(" "),a("li",[a("p",[t._v("在生产中，我们会在 FsStateBackend 和 RocksDBStateBackend 间选择：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("FsStateBackend")]),t._v("：性能更好；日常存储是在堆内存中，面临着 OOM 的风险，不支持增量 checkpoint。")]),t._v(" "),a("li",[a("strong",[t._v("RocksDBStateBackend")]),t._v("：无需担心 OOM 风险，是大部分时候的选择。")])])]),t._v(" "),a("li",[a("p",[t._v("RocksDB")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("在 RocksDB 中，每个 state 独享一个 Column Family，而每个 Column family 使用各自独享的 write buffer 和 block cache，上图中的 window state 和 value state实际上分属不同的 column family。")])]),t._v(" "),a("li",[a("p",[a("img",{attrs:{src:"https://static.lovedata.net/20-08-12-f05823758c252aec44dd11d1da0a768a.png",alt:"image"}})])]),t._v(" "),a("li",[a("p",[t._v("配置")]),t._v(" "),a("ul",[a("li",[a("table",[a("thead",[a("tr",[a("th",[t._v("state.backend.rocksdb.thread.num")]),t._v(" "),a("th",[t._v("后台 flush 和 compaction 的线程数. 默认值 ‘1‘. 建议调大")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("state.backend.rocksdb.writebuffer.count")]),t._v(" "),a("td",[t._v("每个 column family 的 write buffer 数目，默认值 ‘2‘. 如果有需要可以适当调大")])]),t._v(" "),a("tr",[a("td",[t._v("state.backend.rocksdb.writebuffer.size")]),t._v(" "),a("td",[t._v("每个 write buffer 的 size，默认值‘64MB‘. 对于写频繁的场景，建议调大")])]),t._v(" "),a("tr",[a("td",[t._v("state.backend.rocksdb.block.cache-size")]),t._v(" "),a("td",[t._v("每个 column family 的 block cache大小，默认值‘8MB’，如果存在重复读的场景，建议调大")])])])])])])]),t._v(" "),a("li",[a("p",[t._v("实践")]),t._v(" "),a("ul",[a("li",[a("h4",{attrs:{id:"operator-state-使用建议"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#operator-state-使用建议"}},[t._v("#")]),t._v(" Operator state 使用建议")]),t._v(" "),a("ul",[a("li",[t._v("慎重使用长 list  job master 就会因为收到 task 发来的“巨大”的 offset 数组，而内存不断增长直到超用无法正常响应")]),t._v(" "),a("li",[t._v("正确使用 UnionListState。\n"),a("ul",[a("li",[t._v("union list state 目前被广泛使用在 kafka connector 中，不过可能用户日常开发中较少遇到，"),a("strong",[t._v("他的语义是从检查点恢复之后每个并发 task 内拿到的是原先所有operator 上的 state，如下图所示：")])]),t._v(" "),a("li",[a("strong",[a("img",{attrs:{src:"https://static.lovedata.net/20-08-12-85082be4bcaa670c407006efbf51102a.png",alt:"image"}})])])])])])]),t._v(" "),a("li",[a("h4",{attrs:{id:"keyed-state-使用建议"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#keyed-state-使用建议"}},[t._v("#")]),t._v(" "),a("strong",[t._v("Keyed state 使用建议")])]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("如何正确清空当前的 state")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("state.clear() 只能清理当前key的state，如果想要清空整个 state，需要借助于 applyToAllKeys 方法")])]),t._v(" "),a("li",[a("strong",[a("img",{attrs:{src:"https://static.lovedata.net/20-08-12-cc9d7e078ba46da002aba1cf665b0acf.png",alt:"image"}})])]),t._v(" "),a("li",[a("strong",[t._v("state 有过期需求，借助于 state TTL")])])])])])]),t._v(" "),a("li",[a("h4",{attrs:{id:"一些使用-checkpoint-的使用建议"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一些使用-checkpoint-的使用建议"}},[t._v("#")]),t._v(" "),a("strong",[t._v("一些使用 checkpoint 的使用建议")])]),t._v(" "),a("ul",[a("li",[a("h5",{attrs:{id:"checkpoint-间隔不要太短"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#checkpoint-间隔不要太短"}},[t._v("#")]),t._v(" "),a("strong",[t._v("Checkpoint 间隔不要太短")])])]),t._v(" "),a("li",[a("h5",{attrs:{id:"合理设置超时时间"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#合理设置超时时间"}},[t._v("#")]),t._v(" "),a("strong",[t._v("合理设置超时时间")])])])])])])])])])])])}),[],!1,null,null,null);e.default=r.exports}}]);