# 第十七章、垃圾回收器

[toc]

## GC分类与性能指标

![image](https://static.lovedata.net/20-12-30-3ba42ec896747fcb7e7fd9e3d4b17ae0.png-wm)



![image](https://static.lovedata.net/20-12-30-dc0374d5867e9efdb51102d91010dbf6.png-wm)



### 垃圾回收器分类

#### 按照线程数分类

![image](https://static.lovedata.net/20-12-30-e7581ce2bc0e263db793f5bffdbb29d6.png-wm)



![image](https://static.lovedata.net/20-12-30-abee3db08b05ca7755a09f0b3063d26a.png-wm)

#### 按照工作模式

![image](https://static.lovedata.net/20-12-30-ff3f35845b7b2f54aa4c4c06115c7462.png-wm)

#### 按照碎片处理方式分

![image](https://static.lovedata.net/20-12-30-0eebc3223549270904867673f2af4291.png-wm)

### 评估垃圾回收器性能指标

![image](https://static.lovedata.net/20-12-30-854cdd2b9ef485452d20671788d7251e.png-wm)

![image](https://static.lovedata.net/20-12-30-1c6c469b9bfcd5dafee058ca9689c23e.png-wm)

### 吞吐量

> 注重吞吐量，用户代码运行的事件越长越好，不在意一次gc的暂停时间，注重在单位时间内，stw的时间最短

![image](https://static.lovedata.net/20-12-30-81dd85b48fa05885d91599967708ac29.png-wm)



![image](https://static.lovedata.net/20-12-30-28bbdc8444f026df8db956dc6521e21e.png-wm)



### 暂停时间(注重低延迟)

> 每次暂停时间短，但是回收次数比较多,尽可能让每次stw的时间最短

![image](https://static.lovedata.net/20-12-30-35df5a9dbc2424f141c52a8b8190b5fd.png-wm)



>  吞吐量和暂停时间是一对矛盾体

![image](https://static.lovedata.net/20-12-30-e6bb0e9cc380297c3524c0acf7169243.png-wm)



![image](https://static.lovedata.net/20-12-31-70e0ea74b4e8ef445d7329331fa82cfa.png-wm)

G1的标准：在最大吞吐量优先的情况下，降低吞吐量，在可控的时间范围之内，比如10ms，极可能的提交吞吐量。



## 不同垃圾回收器概述

![image](https://static.lovedata.net/20-12-31-6a6fe35edd31c6cd98495e740ad29f9b.png-wm)

![image](https://static.lovedata.net/20-12-31-c9f7e43bfc8484a3a471b95787ba3c67.png-wm)



### 7款经典垃圾回收器

![image](https://static.lovedata.net/20-12-31-0f8e8b8c1c4199d1b348d43af8c610f1.png-wm)



![image](https://static.lovedata.net/20-12-31-729594fa70e38192d92b617ad8c22c06.png-wm)



### 七款垃圾回收器和垃圾分代之间的关系

![image](https://static.lovedata.net/20-12-31-99f4af02f00ee5b956f7cdfc2f2fad3c.png-wm)

### 垃圾收集器的组合关系

![image](https://static.lovedata.net/20-12-31-0ce3e89aed0fc3d9f1f0a3a8b09a0922.png-wm)



> 后备方案，cms是并发的，需要提前回收，垃圾回收的同时，用户线程还在执行，用户还在制造垃圾 。如果回收的比较晚了，活着垃圾制造的速度比垃圾回收还要快，会出现失败情况，失败了，则使用Serial old作为后备方案，触发Full GC， 停止用户线程。

![image](https://static.lovedata.net/20-12-31-76010eb30f388c4b69473290c1b074bd.png-wm)



> 这两个组合，在jdk8中标记为deprecated，在jdk9中，直接删除了

![image](https://static.lovedata.net/20-12-31-4b1e5637739f758994e1313ee55399fb.png-wm)

![image](https://static.lovedata.net/20-12-31-89133872f1c6b356a0215b5fde1baa77.png-wm)

> 疑问：为什么CMS不能和Parallel Scavenge GC 组合使用？
>
> 答：因为底层使用的垃圾回收框架不同，导致无法兼容，却能和ParNew GC 组合使用，性能上ParNew和Parallel Scavenge G差不太多

### 为什么需要这么多垃圾收集器？

![image](https://static.lovedata.net/20-12-31-3689ebe8594a9bbeb130523c01eb4267.png-wm)

## Serial回收器：串行回收

## ParNew回收器：并行回收

## Parallel回收器：吞吐量优先

## CMS回收器：低延迟

## G1回收器：区域化分代式

## 垃圾回收器总结

## GC日志分析

## 垃圾回收器的新发展

