# 第三章、类的加载过程详解

[toc]

## 概述

![image](https://static.lovedata.net/21-01-21-cdd198a05d91d01391834c5fda96eca4.png-wm) 

![image](https://static.lovedata.net/21-01-21-49861e25496938681eb5cd4f273f28dd.png-wm)

### 大厂面试题

![image](https://static.lovedata.net/21-01-21-f691f73c170e9f674c0f0dde77555189.png-wm)

## 过程一：Loading(加载)阶段



### 加载完成操作

![image](https://static.lovedata.net/21-01-21-157c99abdadb34a95e8a63f8518d502e.png-wm)

### 二进制流的获取方式

![image](https://static.lovedata.net/21-01-21-ec6927757958ea5bab2948bd446917d1.png-wm)

### 类模型与class实例的位置

![image](https://static.lovedata.net/21-01-21-e05cdb2c45a9a7b2db5262811b7d2963.png-wm)

![image](https://static.lovedata.net/21-01-26-1c93192e0f91e9202084192003e4396e.png-wm)

![image](https://static.lovedata.net/21-01-26-fa9737460bbf22c59bae4028e5ce8255.png-wm)

### 数组类的加载

![image](https://static.lovedata.net/21-01-26-5b84b2d3fcd7c77a0c143d7a553bc9d0.png-wm)

## 过程二：Linking(链接)阶段

### 环节一：Linking(链接)阶段之Verification(验证)

![image](https://static.lovedata.net/21-01-26-763f54e10d383244bec1f25c829a6ce5.png-wm)

![image](https://static.lovedata.net/21-01-26-6455c60af139e53a7da3cfa6697d1134.png-wm)

![image](https://static.lovedata.net/21-01-26-d72d971fe09bfffeea5c7aa9ee4094aa.png-wm)

![image](https://static.lovedata.net/21-01-26-e11443e0ae905fd303f1ebeba9ca6fc0.png-wm)

![image](https://static.lovedata.net/21-01-26-aec241ae5243bd3a9df9ee91aaca24e3.png-wm)

![image](https://static.lovedata.net/21-01-26-da1e9bc791941c1f02749a4dfa4af177.png-wm)

### 环节二：Linking(链接)阶段之Preparation(准备)

![image](https://static.lovedata.net/21-01-26-4dc24c6f2bda17693df82ada49375934.png-wm)

![image](https://static.lovedata.net/21-01-26-03fa1e246f395622234adcadd296eb33.png-wm)

![image](https://static.lovedata.net/21-01-26-e4f0b702d8684c005954a28aaf79c078.png-wm)

### 环节三：Linking(链接)阶段之Resolution(解析)

![image](https://static.lovedata.net/21-02-04-13e113603a45c606685c462da30219ba.png-wm)

![image](https://static.lovedata.net/21-02-04-0e0f5c1251c273f8b56e83b061bf0400.png-wm)



![image](https://static.lovedata.net/21-02-04-5c2d698817c34733d576e697cee62135.png-wm)

## 过程三：Initialization(初始化)阶段

![image](https://static.lovedata.net/21-02-04-f0892b2985f1ccdbc85768c4caa9d680.png-wm)

 口诀：由父及子，静态先行

![image](https://static.lovedata.net/21-02-04-847ad69f7e17d48d5e56b8b904bd1f36.png-wm)

![image](https://static.lovedata.net/21-02-04-20542d10d0c9fb7184839720e335c426.png-wm)



哪些场景不会生成clint方法

![image](https://static.lovedata.net/21-02-04-f691f73c170e9f674c0f0dde77555189.png-wm)

### static与final的搭配问题

```java

/**
 *
 * 说明：使用static + final修饰的字段的显式赋值的操作，到底是在哪个阶段进行的赋值？
 * 情况1：在链接阶段的准备环节赋值
 * 情况2：在初始化阶段<clinit>()中赋值
 *
 * 结论：
 * 在链接阶段的准备环节赋值的情况：
 * 1. 对于基本数据类型的字段来说，如果使用static final修饰，则显式赋值(直接赋值常量，而非调用方法）通常是在链接阶段的准备环节进行
 * 2. 对于String来说，如果使用字面量的方式赋值，使用static final修饰的话，则显式赋值通常是在链接阶段的准备环节进行
 *
 * 在初始化阶段<clinit>()中赋值的情况：
 * 排除上述的在准备环节赋值的情况之外的情况。
 *
 * 最终结论：使用static + final修饰，且显示赋值中不涉及到方法或构造器调用的基本数据类型或String类型的显式赋值，是在链接阶段的准备环节进行。
 */
public class InitializationTest2 {
    public static int a = 1;//在初始化阶段<clinit>()中赋值
    public static final int INT_CONSTANT = 10;//在链接阶段的准备环节赋值

    public static final Integer INTEGER_CONSTANT1 = Integer.valueOf(100);//在初始化阶段<clinit>()中赋值
    public static Integer INTEGER_CONSTANT2 = Integer.valueOf(1000);//在初始化阶段<clinit>()中赋值

    public static final String s0 = "helloworld0";//在链接阶段的准备环节赋值
    public static final String s1 = new String("helloworld1");//在初始化阶段<clinit>()中赋值

    public static String s2 = "helloworld2";

    public static final int NUM1 = new Random().nextInt(10);//在初始化阶段<clinit>()中赋值
}
```



### Clinit()的线程安全问题

### 类的初始化情况：主动使用和被动使用



## 过程四：类的Using(使用)



## 过程五：类的Unloading(卸载)