# 磁盘

[toc]

## 基础知识

### 概念

> 引用自《Linux就该这么学》

#### 一切都是文件

在Linux系统中，目录、字符设备、块设备、套接字、打印机等都被抽象成了文件，“Linux系统中一切都是文件”。





#### 文件目录布局

![image](https://static.lovedata.net/21-01-15-f7a0d02957172dfde60610e6e4a1f4a5.png)



| 目录名称    | 应防止文件内容                                            |
| ----------- | --------------------------------------------------------- |
| /boot       | 开机所需文件——内核、开机菜单以及所需配置文件等            |
| /dev        | 以文件形式存放任何设备与接口                              |
| /etc        | 配置文件                                                  |
| /home       | 用户家目录                                                |
| /bin        | 存放但用户模式下还可以操作的命令                          |
| /lib        | 开机时用到的函数库，以及/bin与/sbin下面的命令要调用的函数 |
| /sbin       | 开机过程中需要的命令                                      |
| /media      | 用于挂载设备文件的目录                                    |
| /opt        | 放置第三方的软件                                          |
| /root       | 系统管理员的家目录                                        |
| /srv        | 一些网络服务的数据文件目录                                |
| /tmp        | 任何人均可使用的“共享”临时目录                            |
| /proc       | 虚拟文件系统，例如系统内核、进程、外部设备及网络状态等    |
| /usr/local  | 用户自行安装的软件                                        |
| /usr/sbin   | Linux系统开机时不会使用到的软件/命令/脚本                 |
| /usr/share  | 帮助与说明文件，也可放置共享文件                          |
| /var        | 主要存放经常变化的文件，如日志                            |
| /lost+found | 当文件系统发生错误时，将一些丢失的文件片段存放在这里      |

#### 物理设备命名规则

![image](https://static.lovedata.net/21-01-15-9fbf48484a3d89da03bc1d223fdc4447.png)

![image](https://static.lovedata.net/21-01-15-14c29ec0229b8f17e2e2d4652f517bb1.png)

> “/dev/sda5”表示的就是“这是系统中第一块被识别到的硬件设备中分区编号为5的逻辑分区的设备文件”。
>

#### 主分区、扩展分区、逻辑分区的概念

硬盘设备是由大量的扇区组成的，**每个扇区的容量为512字节**。其中第一个扇区最重要，它里面保存着主引导记录与分区表信息。就第一个扇区来讲，**主引导记录需要占用446字节**，分区表为64字节，结束符占用2字节；其中分区表中每记录一个分区信息就需要16字节，这样一来最多只有4个分区信息可以写到第一个扇区中，这4个分区就是4个主分区。

![image](https://static.lovedata.net/21-01-15-aca629948b385b3009413563c2e88a2b.png)

那么问题来了——第一个扇区最多只能创建出4个分区？于是为了解决分区个数不够的问题，可以将第一个扇区的分区表中16字节（原本要写入主分区信息）的空间（称之为扩展分区）拿出来指向另外一个分区。也就是说，扩展分区其实并不是一个真正的分区，而更像是一个占用16字节分区表空间的指针——一个指向另外一个分区的指针。这样一来，用户一般会选择使用3个主分区加1个扩展分区的方法，然后在扩展分区中创建出数个逻辑分区，从而来满足多分区（大于4个）的需求。当然，就目前来讲大家只要明白为什么主分区不能超过4个就足够了。主分区、扩展分区、逻辑分区可以像图64那样来规划。

![image](https://static.lovedata.net/21-01-15-7b1140347289b83ce35e1438d99bb2d2.png)



### 文件系统与数据资料

> 文件 创建删除修改都是依靠**文件系统**完成的，常见如下

#### Ext3

​	日志文件系统 避免系统异常当即文件丢失，自动修复数据，磁盘越大，修复时间越长，不能百分百保证。

​	会预记录每个吸入动作，，以便能够追溯

#### Ext4

​	Ext3的改进版本，是RHEL6系统默认文件系统。最高1EB，无限子目录，速度搞

#### XFS

高性能 ，而且是RHEL7中默认的文件管理系统 ，优势：系统宕机后快速修复可能被破坏的文件。最大18EB

> 拿到一个硬盘，首先进行分区，然后再格式化文件系统，才能挂载正常使用。 
>
> 硬盘分区操作取决于需求和硬盘大小
>
> 也可以不分区，但必须格式化



## 挂载硬件设备

### mount命令

```shell
mount 文件系统 挂载目录
mount /dev/sdb2 /backup
```

![image](https://static.lovedata.net/21-01-15-0dc688da754a09f44dc89d777b107258.png)

> mount之后能立即使用了，重启后挂载失效，每次启动都要手动挂载一下。\
>
> 必须把挂载信息按照指定格式。"设备文件 挂载目录 格式类型。权限选项 自检 优先级" 写入到 /tc/fstab 文件中

用于挂载信息的指定填写格式中，各字段所表示的意义

| 字段     | 意义                                                         |
| -------- | ------------------------------------------------------------ |
| 设备文件 | 一般为设备的路径+设备名称，也可以写唯一识别码（UUID，UniversallyUniqueIdentifier |
| 挂载目录 | 指定要挂载到的目录，需在挂载前创建好                         |
| 格式类型 | 指定文件系统的格式，比如Ext3、Ext4、XFS、SWAP、iso9660（此为光盘设备）等 |
| 权限选项 | 若设置为defaults，则默认权限为：rw,suid,dev,exec,auto,nouser,async |
| 自检     | 若为1则开机后进行磁盘自检，为0则不自检查                     |
| 优先级   | 若“自检”为1，则可对多块磁盘进行自检设置优先级                |

```shell
vim /etc/fstab
/dev/sdb2 		/backup ext4 defaults 0 0
```

### unmout

```shell
umount /dev/sdb2
```

### fdisk

fdisk命令中的参数和作用

![image](https://static.lovedata.net/21-01-15-4502bc81edaf42d6d24cd20dd1ba3d9a.png)

使用fdisk命令来尝试管理/dev/sdb硬盘设备

```shell
fdisk /dev/sdb
# 输入p查看已经有的分区
# 输入n 来创建分区
# 输入 p 来创建主分区
# 提示输入分区编号，主分区默认是 1-4，所以回车
# 提示输入起始的扇区编号，直接回车
# 输入最后一个分区的位置 +size{K,M,G} 输入 +2G
# 在使用p查看分区信息
file /dev/sdb1 # 查看文件属性信息
partprobe # 同步文件信息到内核
mkfs.xfs /dev/sdb1 # 格式化分区为XFS文件系统
mkdir /newFS
mount /dev/sdb1 /newFS
df -h
```





### parted

[分区工具parted的详解及常用分区使用方法_伏虎游侠的博客-CSDN博客](https://blog.csdn.net/dufufd/article/details/53508367)

## 逻辑卷管理

### 逻辑卷管理详解

[LVM原理及PV、VG、LV、PE、LE关系图_北极星的专栏-CSDN博客_lvm pe](https://blog.csdn.net/lenovouser/article/details/54233570)

  在**零停机**前提下可以自如对文件系统的大小进行调整，可以方便实现文件系统跨越不同磁盘和分区。那么我们可以通过逻辑盘卷管理（LVM，Logical Volume Manager）的方式来非常完美的实现这一功能。

-  LVM是逻辑盘卷管理（Logical Volume Manager） 一种磁盘管理工具
- LVM是建立在硬盘和分区之上的一个逻辑层，来提高磁盘分区管理的灵活性
- 能够实现
  - 若干个磁盘分区连接为一个整块的卷组（volume group）形成一个存储池
  - 在卷组上随意创建逻辑卷组（logical volumes）
  - 并进一步在逻辑卷组上创建文件系统
  - 管理员通过LVM可以方便的调整存储卷组的大小
  - 对磁盘存储按照组的方式进行命名、管理和分配 随便取名字 比如 DBData 而不是使用 sda sdb 

![image](https://static.lovedata.net/21-01-06-7f984fae6c53848f218010bc6aa4172c.png)

#### LVM基本术语

1. 物理存储介质（The physical media）指硬盘

2. 物理卷(physical volume) 

   1. 物理卷就是指硬盘分区或从逻辑上与磁盘分区具有同样功能的设备(如RAID)，是LVM的基本存储逻辑块

3. 卷组（Volume Group）

   1. LVM卷组类似于非LVM系统中的物理硬盘，其由物理卷组成。
   2. 可以在卷组上建立多个LVM分区（逻辑卷）
   3. LVM卷组有一个或多个物理卷组成

4. 逻辑卷（Logicalvolume）

   1. LVM的逻辑卷类似于非LVM系统中的硬盘分区

5. PE（physical extent）

   1. 物理卷被划分为称为PE(Physical Extents)的基本单元
   2. 有编号，PE是可以被LVM寻址的最小单元，可配置 默认 4MB

6. LE（logical extent）

   1. 逻辑卷也被分成为LE的可被寻址的基本单位
   2. 同一个卷组与PE大小相同，一一对应

   ![image](https://static.lovedata.net/21-01-06-c50f972ab1c65e6a1ce9a108208721af.png)

   ![image](https://static.lovedata.net/21-01-06-fe7583ce01b4e7d8b6fa3dd62e605307.png)

磁盘分区、卷组、逻辑卷和文件系统之间的逻辑关系的示意图

![image](https://static.lovedata.net/21-01-06-2d3436190f33b215a4d3379367adb0a3.png)

### Linux就该这么学

LVM可以允许用户对硬盘资源进行动态调整

![image](https://static.lovedata.net/21-01-15-2dbd4d2ecc34827ee3058a550cde1029.png)

#### 核心概念

**物理卷**处于LVM中的最底层，可以将其理解为物理硬盘、硬盘分区或者RAID磁盘阵列，这都可以。卷组建立在物理卷之上，**一个卷组可以包含多个物理卷**，而且在卷组创建之后也可以继续向其中添加新的物理卷。逻辑卷是用卷组中空闲的资源建立的，并且逻辑卷在建立后可以动态地扩展或缩小空间

### LVM常用步骤

#### 第一步 让新添加的两块硬盘设备支持LVM技术。

```shell
pvcreate/dev/sdb/dev/sdc
```

#### 第二步 把两块硬盘设备加入到storage卷组中，然后查看卷组的状态。

```shell
vgcreatestorage/dev/sdb/dev/sdc
vgdisplay
```

#### 第三步 第3步：切割出一个约为150MB的逻辑卷设备。

> 两种计量单位
>
> 1. 以容量单位 -L 如 -L 150M 生成一个150M的逻辑卷
> 2. 以个数为单位，-l 每个基本单元的大小默认为4MB，例如 -l37 生成 37X4MB=148MB的逻辑卷

```shell
lvcreate -n vo -l 37 storage
lvdisplay
```

#### 第4步：把生成好的逻辑卷进行格式化，然后挂载使用

> Linux系统会把LVM中的逻辑卷设备存放在/dev设备目录中（实际上是做了一个符号链接），同时会以卷组的名称来建立一个目录，其中保存了逻辑卷的设备映射文件（即/dev/卷组名称/逻辑卷名称）。

```shell
mkfs.ext4 /dev/storage/vo
```



#### 第5步：查看挂载状态，并写入到配置文件，使其永久生效

```shell
df -h
echo "/dev/storage/vo /linuxprobe ext4 defaults 0 0">>/etc/fstab
```



### LVM扩容

> 扩展前请一定要记得卸载设备和挂载点的关联。
>

```shell
umount /linuxprobe
```



#### 第一步 把上一个实验的逻辑卷扩容到290MB

```shell
lvextend -L 290M /dev/storage/vo
```

#### 第二步  检查硬盘完整性，并充值硬盘容量

```shell
e2fsck -f /dev/storage/vo
resize2fs /dev/storage/vo
```

#### 第三步 重新挂载硬盘设备并检查挂载状态

```shell
mount -a
df -h
```



### LVM缩容

> 缩容要先检查系统完整性，并且备份好磁盘数据

```shell
umount /linuxprobe
```

#### 第1步：检查文件系统的完整性。

```shell
e2fsck -f /dev/storage/vo
```

#### 第2步：把逻辑卷vo的容量减小到120MB。

```shell
resize1fs /dev/storage/vo 120M
```

#### 第3步 重新挂在磁盘检查状态

```shell
mount -a
df -h
```















## RAID(独立冗余磁盘阵列)

> 摘自《Linux就该这么学》

### 由来

CPU性能高速增长，为磁盘性能提升优先，逐渐成为瓶颈，并且磁盘持续、频繁IO操作，损坏几率更大，数据丢失的几率也增加。

RAID技术通过把多个**硬盘设备**组合成一个**容量更大**、**安全性更好**的磁盘阵列，并把数据切割成多个区段后分别存放在各个不同的物理硬盘设备上，然后利用**分散读写**技术来**提升磁盘阵列整体的性能**，同时把多个**重要数据的副本**同步到不同的物理硬盘设备上，从而起到了非常好的数据**冗余备份**效果。

缺点：数据多份，有成本。 但是数据本身价值更大，现代企业更看重冗余备份和带来的磁盘吞吐量的提升。 



### RAID 0 

把多块物理硬盘设备（至少两块）串联在一起，组成一个大的卷组。 

数据依次写入每个物理磁盘。

读写性能提升数倍，但是任意一个硬盘损坏，整个系统数据都被破坏。

提升吞吐速度，不具备数据容错能力

![image](https://static.lovedata.net/21-01-07-f568482573164a6f405df4a7b4592e38.png)



### RAID1

RAID0 数据是分开存放的。

如果生产环境对硬盘设备的读写速度没有要求，而是希望增加数据的安全性时，就需要用到RAID1技术

如果，由两块以上的硬盘进行绑定，同时写入多块设备上，一块硬盘故障，会立即自动移热交换方式恢复数据

![image](https://static.lovedata.net/21-01-07-c722b4c4f17e63f221c1dfd2f7dbd46e.png)



缺点：

1. 磁盘利用率低下，上图只有50%
2. 数据同时写入两块以上磁盘，增加系统负载

### RAID5 

RAID5技术虽然在理论上兼顾了三者（读写速度、数据安全性、成本），但实际上更像是对这三者的“相互妥协”

把硬盘设备的奇偶校验信息保存在其他硬盘设备中，好处是其中任何一块设备损坏后不至于出现致命缺陷。 

并没有别分硬盘的真实数据，而是在硬盘损坏后通过奇偶校验信息尝试重建损坏的数据。

是一种妥协，坚固了读写速度、数据安全性和存储成本

![image](https://static.lovedata.net/21-01-07-3df65504fc8f8dfaf9b9de9daba29342.png)



### RAID10

RAID5 是妥协

大部分企业更在乎的是数据本身的价值而非硬盘价格，因此生产环境中主要使用RAID10技术。

RAID10技术是RAID1+RAID0技术的一个“组合体”。 

至少4块硬盘来组建，分别 两辆制作 RAID1磁盘阵列，保证**数据安全性**

然后对两个RIAID1磁盘阵列试试RAID0技术，提升读写速度

只要不坏一个组所有硬盘，最多可以损坏百分之五十的硬盘不丢失数据

吸取了RAID0 高速读写 和 RAID1 数据安全的，不考虑成本下，性能超过RAID5

![image](https://static.lovedata.net/21-01-07-f4677dbc1254051fd919379f6cc69400.png)



